#### 题目如下：

> 给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
>
> 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
>
> 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
>
> **示例 :**
>
> 输入:
> [[0,1,0,0],
> [1,1,1,0],
>  [0,1,0,0],
>  [1,1,0,0]]
>  
> 输出: 16
> 
> 解释: 它的周长是下面图片中的 16 个黄色的边：
> 
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)



### 解题思路如下：

刚拿到这道题时，好长时间一筹莫展，最后是看了别人的答案才慢慢把思路给捋顺的；

整体思路是先加后减，只要遍历到陆地就加 4，同时上和左有陆地接壤时再减去 2；

也看到有人的解题思路是每次判断当前陆地的上下左右 4 个方向上是否有陆地，有一块陆地减 1，有两块陆地减 2，有三块陆地减 3，有四块陆地减 4；

不过这个思路不如上一个思路优秀，这个每次要判断 4 次，上一个思路，每次只用判断 2 次（上和左两个方向）；

把第一个思路细分一下，步骤如下：

1. 遍历每一个方格，遇到陆地就加 4；
2. 同时，如果当前陆地的上方也是陆地，则从结果中减去 2；
3. 同时，如果当前陆地的左边也是陆地，则从结果中减去2；

然后是代码：

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        if (grid == null || grid.length == 0) {
			return 0;
		}
		int result = 0;
		for (int i = 0; i < grid.length; i++) {
			for (int j = 0; j < grid[i].length; j++) {
				if (grid[i][j] == 1) {
					//遍历时遇到陆地，先给结果加 4
					result += 4;
					if (i > 0 && grid[i - 1][j] == 1) {
						//如果当前陆地的上边也有陆地，刚这两块陆地因为接壤，从结果中减去各自的一条边
						result -= 2;
					}
					if (j > 0 && grid[i][j - 1] == 1) {
						//如果当前陆地的左侧也有一块陆地，则这两块陆地因为接壤，从结果中减去各自的一条边
						result -= 2;
					}

				}
			}
		}
		return result;
    }
}
```



